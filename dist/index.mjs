import { SvelteComponent, init, safe_not_equal, element, insert, noop, detach, binding_callbacks } from 'svelte/internal';
import { createEventDispatcher, onMount, onDestroy } from 'svelte';
import { debounce } from 'lodash-es';

/* src/index.svelte generated by Svelte v3.6.7 */

function create_fragment(ctx) {
	var div;

	return {
		c() {
			div = element("div");
		},

		m(target, anchor) {
			insert(target, div, anchor);
			ctx.div_binding(div);
		},

		p: noop,
		i: noop,
		o: noop,

		d(detaching) {
			if (detaching) {
				detach(div);
			}

			ctx.div_binding(null);
		}
	};
}

const INPUT_EVENT_DEBOUNCE_WAIT = 300;

function instance_1($$self, $$props, $$invalidate) {
	
  
  // Properties
  let { editor = null, value = '', config = () => ({}) } = $$props;
  let { disabled = false } = $$props;

  // Instance variables
  let instance = null;
  let lastEditorData = '';
  let editorElement;
  const dispatch = createEventDispatcher();

  function watchValue(x) {
    if (instance && x !== lastEditorData){
      instance.setData(x);
    }
  }


  onMount( () => {

    // If value is passed then add it to config
    if(value) {
      Object.assign(config, {
        initialData: value
      });
    }

    editor.create(editorElement, config)
    .then(editor => {

        // Save the reference to the instance for future use.
        instance = editor;

        // Set initial disabled state.
        editor.isReadOnly = disabled;
        
        // Let the world know the editor is ready.
        dispatch('ready', editor);

        setUpEditorEvents();

    })
    .catch( error => {
        console.error( error );
    });

  });

  onDestroy(() => {
    
    if (instance ) {
      instance.destroy();
      instance = null;
    }

    // Note: By the time the editor is destroyed (promise resolved, editor#destroy fired)
    // the Vue component will not be able to emit any longer. So emitting #destroy a bit earlier.
    dispatch('destroy', instance);
  });

  function setUpEditorEvents() {
      const emitInputEvent = evt => {
        // Cache the last editor data. This kind of data is a result of typing,
        // editor command execution, collaborative changes to the document, etc.
        // This data is compared when the component value changes in a 2-way binding.
        // const data = value = lastEditorData = instance.getData()
        const data = value = lastEditorData = instance.getData();
        dispatch('input', { data, evt, instance }); $$invalidate('value', value);
      };

      // Debounce emitting the #input event. When data is huge, instance#getData()
      // takes a lot of time to execute on every single key press and ruins the UX.
      instance.model.document.on( 'change:data', debounce( emitInputEvent, INPUT_EVENT_DEBOUNCE_WAIT ));

      instance.editing.view.document.on( 'focus', evt => {
        dispatch('focus',{ evt, instance });
      });

      instance.editing.view.document.on( 'blur', evt => {
        dispatch('blur', { evt, instance });
      });
    }

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('editorElement', editorElement = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('config' in $$props) $$invalidate('config', config = $$props.config);
		if ('disabled' in $$props) $$invalidate('disabled', disabled = $$props.disabled);
	};

	$$self.$$.update = ($$dirty = { value: 1 }) => {
		if ($$dirty.value) { watchValue(value); }
	};

	return {
		editor,
		value,
		config,
		disabled,
		editorElement,
		div_binding
	};
}

class Index extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance_1, create_fragment, safe_not_equal, ["editor", "value", "config", "disabled"]);
	}
}

export default Index;
